name: Build and deploy Sonexa Backend to DigitalOcean
run-name: ${{ github.actor }} is deploying to production server ðŸš€

on:
  push:
    branches:
      - main
    paths:
      - "backend/**"
      - ".github/workflows/deploy-backend.yml"
  workflow_dispatch:

jobs:
  build-and-publish:
    name: build and publish image
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login docker.io -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

      - name: Create .env file
        run: |
          cd backend
          cat > .env << EOL
          DOCKER_IMAGE=${{ secrets.DOCKER_USERNAME }}/sonexa-ai-backend
          IMAGE_TAG=latest
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          SSL_ENABLED=${{ secrets.SSL_ENABLED || 'false' }}
          EOL
          echo "Environment file created"
          # Show non-sensitive variables
          grep -v "PASSWORD\|SECRET" .env || true

      - name: Build and Publish
        run: |
          cd backend
          docker compose -f docker-compose.prod.yml build --no-cache
          docker compose -f docker-compose.prod.yml push

  deployment:
    needs: build-and-publish
    name: deploy image
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: rsync docker compose config and files
        uses: burnett01/rsync-deployments@5.2.1
        with:
          switches: -avzr --delete
          path: backend/
          remote_path: sonexa-ai
          remote_host: ${{ secrets.DO_HOST }}
          remote_user: ${{ secrets.DO_USERNAME }}
          remote_key: ${{ secrets.DO_SSH_KEY }}

      - name: connect and deploy
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT }}
          script: |
            # Navigate to deployment directory
            cd sonexa-ai

            # Stop and remove existing containers to avoid conflicts
            echo "Stopping existing containers..."
            docker-compose -f docker-compose.prod.yml down --remove-orphans || true

            # Remove any conflicting containers by name
            echo "Removing conflicting containers..."
            docker rm -f sonexa-postgres-prod sonexa-backend-prod sonexa-nginx-prod || true

            # Check if postgres volume is corrupted and recreate if necessary
            echo "Checking postgres volume..."
            if docker volume ls | grep -q sonexa-ai_postgres_data; then
              echo "Postgres volume exists, checking for corruption..."
              # Optional: Remove volume if there are persistent issues
              # docker volume rm sonexa-ai_postgres_data || true
            fi

            # Clean up old resources (but preserve volumes to keep data)
            echo "Cleaning up unused resources..."
            docker system prune -f

            # Create network if it doesn't exist
            echo "Creating Docker network..."
            docker network create sonexa-network || true

            # Create environment file
            echo "Creating environment file..."
            cat > .env << 'EOL'
DOCKER_IMAGE=${{ secrets.DOCKER_USERNAME }}/sonexa-ai-backend
IMAGE_TAG=latest
DATABASE_NAME=${{ secrets.DATABASE_NAME }}
DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}
DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS }}
JWT_SECRET=${{ secrets.JWT_SECRET }}
SSL_ENABLED=${{ secrets.SSL_ENABLED || 'false' }}
EOL

            # Verify environment file was created correctly
            echo "Environment file contents (non-sensitive):"
            grep -v "PASSWORD\|SECRET" .env

            # Test environment variable loading
            echo "Testing environment variable loading..."
            set -a && source .env && set +a
            echo "DATABASE_NAME loaded as: $DATABASE_NAME"
            echo "DATABASE_USERNAME loaded as: $DATABASE_USERNAME"
            echo "DOCKER_IMAGE loaded as: $DOCKER_IMAGE"

            # Login to Docker Hub
            echo "Logging into Docker Hub..."
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login docker.io --username "${{ secrets.DOCKER_USERNAME }}" --password-stdin

            # Pull latest images
            echo "Pulling latest images..."
            docker compose -f docker-compose.prod.yml pull

            # Test Docker Compose variable substitution
            echo "Testing Docker Compose variable substitution..."
            docker compose -f docker-compose.prod.yml --env-file .env config | head -20

            # Create necessary directories
            echo "Creating necessary directories..."
            mkdir -p logs backup ssl
            chmod 755 logs backup

            # Start database first
            echo "Starting postgres database..."
            docker compose -f docker-compose.prod.yml --env-file .env up -d postgres

            # Wait for postgres to initialize
            echo "Waiting for postgres to initialize..."
            sleep 20

            # Check postgres container status
            echo "Postgres container status:"
            docker ps -a | grep postgres || echo "No postgres container found"

            # Check postgres logs
            echo "Postgres container logs:"
            docker compose -f docker-compose.prod.yml logs postgres --tail 30

            # Check postgres environment variables
            echo "Postgres container environment variables:"
            docker exec sonexa-postgres-prod env | grep POSTGRES || echo "Could not retrieve postgres env vars"

            # Wait for database to be ready with better error handling
            echo "Waiting for database to be ready..."
            database_ready=false

            # Source the environment variables for the health check
            set -a && source .env && set +a

            for i in {1..60}; do
              # First check if postgres container is running
              if ! docker ps | grep -q sonexa-postgres-prod; then
                echo "Postgres container is not running, attempt $i/60"
                echo "Container status:"
                docker ps -a | grep postgres || echo "No postgres container found"
                sleep 10
                continue
              fi
              
              # Check if container is healthy using pg_isready with the actual username
              if docker exec sonexa-postgres-prod pg_isready -U "$DATABASE_USERNAME" -d "$DATABASE_NAME"; then
                echo "Database is ready!"
                database_ready=true
                break
              else
                echo "Database not ready yet, attempt $i/60..."
                if [ $((i % 10)) -eq 0 ]; then
                  echo "Recent postgres logs:"
                  docker compose -f docker-compose.prod.yml logs postgres --tail 10
                fi
                sleep 5
              fi
            done

            if [ "$database_ready" = false ]; then
              echo "Database failed to become ready after 5 minutes"
              echo "Final postgres logs:"
              docker compose -f docker-compose.prod.yml logs postgres --tail 50
              echo "Container inspect:"
              docker inspect sonexa-postgres-prod || echo "Could not inspect container"
              exit 1
            fi

            # Now start the backend
            echo "Starting backend service..."
            docker compose -f docker-compose.prod.yml --env-file .env up -d backend

            # Wait additional time for backend to start
            echo "Waiting for backend service to start..."
            sleep 45

            # Check service status
            echo "Current container status:"
            docker ps -a

            # Check backend logs before health check
            echo "Backend logs (last 20 lines):"
            docker compose -f docker-compose.prod.yml logs backend --tail 20

            # Verify backend health with more detailed checks
            echo "Starting health checks..."
            for i in {1..15}; do
              # First check if container is running
              if ! docker ps | grep -q sonexa-backend-prod; then
                echo "Backend container is not running, attempt $i/15"
                sleep 10
                continue
              fi
              
              # Then check health endpoint
              if curl -s -f http://localhost:8080/actuator/health | grep -q "UP"; then
                echo "Backend health check successful!"
                echo "Deployment completed successfully!"
                exit 0
              else
                echo "Health check attempt $i/15 failed, retrying in 10 seconds..."
                sleep 10
              fi
            done

            echo "Deployment verification failed after 15 attempts"
            echo "=== DEBUGGING INFORMATION ==="

            echo "Final container status:"
            docker ps -a

            echo "Network information:"
            docker network ls

            echo "Backend container logs (last 100 lines):"
            docker compose -f docker-compose.prod.yml logs backend --tail 100

            echo "Database container logs (last 50 lines):"
            docker compose -f docker-compose.prod.yml logs postgres --tail 50

            echo "Checking if backend port is accessible:"
            netstat -tulpn | grep :8080 || echo "Port 8080 not listening"

            echo "Environment variables in backend container:"
            docker exec sonexa-backend-prod env | grep -E "(DATABASE|SPRING|GOOGLE|JWT|CORS)" || echo "Could not retrieve environment variables"

            exit 1
